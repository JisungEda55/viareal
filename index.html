    function drawCanvasPreview() {
      if (!mainImg || !selfieImg) return;

      const layout = layoutSelect.value;
      ctx.clearRect(0, 0, canvasW, canvasH);
      ctx.fillStyle = "#fff";
      ctx.fillRect(0, 0, canvasW, canvasH);

      ctx.save();

      if (layout === 'split-horizontal') {
        const halfH = canvasH / 2;
        drawImageWithCover(ctx, mainImg, 0, 0, canvasW, halfH);
        drawImageWithCover(ctx, selfieImg, 0, halfH, canvasW, halfH);
      } else if (layout === 'split-vertical') {
        const halfW = canvasW / 2;
        drawImageWithCover(ctx, mainImg, 0, 0, halfW, canvasH);
        drawImageWithCover(ctx, selfieImg, halfW, 0, halfW, canvasH);
      } else if (layout === 'side-by-side') {
        const halfW = canvasW / 2;
        drawImageWithCover(ctx, mainImg, 0, 0, halfW, canvasH);
        drawImageWithCover(ctx, selfieImg, halfW, 0, halfW, canvasH);
      } else {
        // Main image in rounded frame
        const frameX = 37.5, frameY = 50, frameW = 825, frameH = 1100;
        ctx.beginPath();
        ctx.roundRect(frameX, frameY, frameW, frameH, frameRadius);
        ctx.clip();
        drawImageWithCover(ctx, mainImg, frameX, frameY, frameW, frameH);

        // Selfie overlay
        let sx = frameX + frameW - selfieSize - margin;
        let sy = frameY + margin;
        if (layout === 'bottom-left') {
          sx = frameX + margin;
          sy = frameY + frameH - selfieSize - margin;
        } else if (layout === 'center-overlay') {
          sx = frameX + (frameW - selfieSize) / 2;
          sy = frameY + (frameH - selfieSize) / 2;
        }

        // Draw black border
        ctx.save();
        ctx.beginPath();
        ctx.roundRect(sx - 3, sy - 3, selfieSize + 6, selfieSize + 6, 16);
        ctx.fillStyle = "#000";
        ctx.fill();

        // Draw selfie
        ctx.beginPath();
        ctx.roundRect(sx, sy, selfieSize, selfieSize, 12);
        ctx.clip();
        drawImageWithCover(ctx, selfieImg, sx, sy, selfieSize, selfieSize);
        ctx.restore();
      }

      ctx.restore();
      downloadBtn.disabled = false;
    }

    function loadImage(file, callback) {
      const reader = new FileReader();
      reader.onload = function(e) {
        const img = new Image();
        img.onload = () => callback(img);
        img.src = e.target.result;
      };
      reader.readAsDataURL(file);
    }

    mainInput.addEventListener('change', e => {
      if (e.target.files[0]) {
        loadImage(e.target.files[0], img => {
          mainImg = img;
          drawCanvasPreview();
        });
      }
    });

    selfieInput.addEventListener('change', e => {
      if (e.target.files[0]) {
        loadImage(e.target.files[0], img => {
          selfieImg = img;
          drawCanvasPreview();
        });
      }
    });

    layoutSelect.addEventListener('change', drawCanvasPreview);

    downloadBtn.addEventListener('click', () => {
      const scale = 2;
      const highCanvas = document.createElement('canvas');
      highCanvas.width = canvasW * scale;
      highCanvas.height = canvasH * scale;
      const highCtx = highCanvas.getContext('2d');

      function drawHighRes() {
        const layout = layoutSelect.value;
        highCtx.fillStyle = "#fff";
        highCtx.fillRect(0, 0, highCanvas.width, highCanvas.height);

        if (layout === 'split-horizontal') {
          const halfH = highCanvas.height / 2;
          drawImageWithCover(highCtx, mainImg, 0, 0, highCanvas.width, halfH);
          drawImageWithCover(highCtx, selfieImg, 0, halfH, highCanvas.width, halfH);
        } else if (layout === 'split-vertical' || layout === 'side-by-side') {
          const halfW = highCanvas.width / 2;
          drawImageWithCover(highCtx, mainImg, 0, 0, halfW, highCanvas.height);
          drawImageWithCover(highCtx, selfieImg, halfW, 0, halfW, highCanvas.height);
        } else {
          const frameX = 37.5 * scale, frameY = 50 * scale;
          const frameW = 825 * scale, frameH = 1100 * scale;
          const radius = frameRadius * scale;
          const sSize = selfieSize * scale;
          const m = margin * scale;

          highCtx.save();
          highCtx.beginPath();
          highCtx.roundRect(frameX, frameY, frameW, frameH, radius);
          highCtx.clip();
          drawImageWithCover(highCtx, mainImg, frameX, frameY, frameW, frameH);

          let sx = frameX + frameW - sSize - m;
          let sy = frameY + m;
          if (layout === 'bottom-left') {
            sx = frameX + m;
            sy = frameY + frameH - sSize - m;
          } else if (layout === 'center-overlay') {
            sx = frameX + (frameW - sSize) / 2;
            sy = frameY + (frameH - sSize) / 2;
          }

          highCtx.save();
          highCtx.beginPath();
          highCtx.roundRect(sx - 6, sy - 6, sSize + 12, sSize + 12, 24);
          highCtx.fillStyle = "#000";
          highCtx.fill();

          highCtx.beginPath();
          highCtx.roundRect(sx, sy, sSize, sSize, 24);
          highCtx.clip();
          drawImageWithCover(highCtx, selfieImg, sx, sy, sSize, sSize);
          highCtx.restore();
        }
      }

      drawHighRes();
      const link = document.createElement('a');
      link.download = 'viareal-moment.png';
      link.href = highCanvas.toDataURL('image/png');
      link.click();
    });

    CanvasRenderingContext2D.prototype.roundRect = function (x, y, w, h, r) {
      if (w < 2 * r) r = w / 2;
      if (h < 2 * r) r = h / 2;
      this.beginPath();
      this.moveTo(x + r, y);
      this.arcTo(x + w, y, x + w, y + h, r);
      this.arcTo(x + w, y + h, x, y + h, r);
      this.arcTo(x, y + h, x, y, r);
      this.arcTo(x, y, x + w, y, r);
      this.closePath();
      return this;
    };
  </script>
</body>
</html>
